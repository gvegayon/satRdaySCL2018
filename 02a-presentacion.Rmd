---
title: "Untitled"
author: "George G. Vega Yon"
date: "December 12, 2018"
output:
  revealjs::revealjs_presentation:
    self_contained: true
    transition: fade
    theme: simple
    reveal_options:
      controls: false
      slideNumber: true
      margin: 0.05
      width: 1024
      height: 780
    css: "slides.css"
    slide_level: 2
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## El paquete parallel

## Flujo de trabajo

Usualmente, es de la siguiente manera:

1.  Crear el cluster de tipo `PSOCK/FORK` (u otro) utilizando la función
    `makePSOCKCluster`/`makeForkCluster` (o `makeCluster`)
    
2.  Preparar la sesion de R en cada processo hijo:

    a.  Copiar objetos con `clusterExport`

    b.  Evaluar expression con `clusterEvalQ`

    c.  Establecer una semilla

3.  Hacer la llamada: `parApply`, `parLapply`, etc. 

4.  Finalizar el cluster con `clusterStop`


## Tipos de Clusters: PSOCK

-   Puede ser creado con `makePSOCKCluster`

-   Inicia una sesion de R desde 0 (nada heredado de la sesion madre), e.g.
    
    ```r
    # Esto genera un cluster con 4 hilos
    cl <- makePSOCKCluster(4)
    ```

-   Los procesos dependientes se comunican con el proceso madre a través de una
    conexión de tipo socket.

-   Tiene la ventaja de que puede crear clusters que incorporan otros
    CPUs, por ejemplo. un cluster con más de un computador!

## Tipos de Clusters: Fork

-   Fork Cluster `makeForkCluster`:

-   Utiliza [*Forking*](https://en.wikipedia.org/wiki/Fork_(system_call)) de
    procesos en el sistema operativo.

-   Genera una copia de la sesion de R actual de forma tal de que todo lo disponible
    en la sesion madre al momento de la creación del cluster se encontrará disponible
    en los procesos hijos..
    
-   Los datos son duplicados sólo si son modificados 
    (need to double check when this happens!)

-   No está disponible para Windows.

Otros tipos de cluster utilizando la función `makeCluster` pueden ser creados
con este paquete utilizandp el paquete [**snow**](https://cran.r-project.org/package=snow)
(*Simple Network of Workstations*).

## Ejemplo 1: Estimando $\pi$

## Ejemplo 2: Bootstrap

```{r ejemplo2-boot}
mi_boot <- function(dat, stat, R, ncpus = 1L) {
  
  # Generando indices aleatorios
  n <- nrow(dat)
  idx <- matrix(sample.int(n, n*R, TRUE), nrow=n, ncol=R)
 
  # Creando cluster 
  cl <- parallel::makePSOCKcluster(ncpus) # Generando instancias de R
  parallel::clusterSetRNGStream(cl, 123)  # Semilla
  on.exit(parallel::stopCluster(cl))      # Detener al salir
  
  # En el caso de PSOCK Cluster necesitamos exportar las variables a usar
  parallel::clusterExport(cl, c("dat", "stat", "idx", "R"), envir = environment())
  
  # Llamando funcion
  t(parallel::parSapply(cl, seq_len(R), function(i) {
    stat(dat[idx[,i], , drop=FALSE])
  }))
  
}
```

---

```{r ejemplo2-boot-cont, cache = TRUE}
# Bootstrap the modelo OLS
mi_stat <- function(d) {
  coef(lm(y ~ x, data=d))
}

# Simulando data
set.seed(1)
n <- 500
R <- 1e4

x <- cbind(rnorm(n))
y <- x*5 + rnorm(n)

# Chequeando que obtenemos datos razonables. Boot puede ser comparado con el 
# intervalo de confianza que obtenemos de la regresion lineal.
ans0 <- confint(lm(y~x))

# Generando distribucion posterior
ans1 <- mi_boot(dat = data.frame(x, y), mi_stat, R = R, ncpus = 2L)

# Comparando IC con el bootstrap rustico y el modelo OLS.
t(apply(ans1, 2, quantile, c(.025,.975)))
ans0
```

---

```{r ejemplo2-boot-benchmark, cache = TRUE}
library(microbenchmark)
microbenchmark(
  "1 Core" = mi_boot(dat = data.frame(x, y), mi_stat, R = 5000, ncpus = 1L),
  "2 Core" = mi_boot(dat = data.frame(x, y), mi_stat, R = 5000, ncpus = 2L),
  times = 1L
  )
```


